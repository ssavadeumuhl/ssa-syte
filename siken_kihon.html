<html>
<head>
<link rel="shortcut icon" href="./favicon.ico">
<link href="css/cs1.css" rel="stylesheet"><!--メインcss-->
<link href="css/cs2.css" rel="stylesheet"><!--ページの入れ替えに必要なcss-->
<script type="text/javascript" src="js/js_header.js"></script>
<script type="text/javascript" src="js/js_footer.js"></script>
<script type="text/javascript" src="js/js_sidebox.js"></script
<script type="text/javascript" src="js/scroll_keep.js"></script>

<title>基本情報午後試験対策ノート</title>
</head>
<body>
<script type="text/javascript">header()</script>

<div class="d1">
  <div style="padding : 20px;"></div>
  <script type="text/javascript">sidebox()</script>
  <div class="d1-1">
  <a href="index.html">ホーム</a>
  &raquo;
  <a href="osiken_kihon.html">基本情報午後ノート</a>
  </div>
  <a href="#" onclick="disp('page1');">
  <div class="mapbox2">セキュ
  </div></a>
  <a href="#" onclick="disp('page2');">
  <div class="mapbox2">デタベ
  </div></a>
  <a href="#" onclick="disp('page3');">
  <div class="mapbox2">3問目
  </div></a>
  <a href="#" onclick="disp('page4');">
  <div class="mapbox2">アルゴ
  </div></a>
  <a href="#" onclick="disp('page5');">
  <div class="mapbox2">表計算
  </div></a>
  <div class="autoscrollbox">
  </div>

  <div class="contents" id="page1">
  <div class="d1-1">
<h2 id="i1-1">セキュリティ</h2>
クラウドサービスの利用者認証に関する次の記述を読んで，設問1，2に答えよ。
<br>
　A社では現在，Webベースの業務システムが複数稼働しており，それぞれが稼働するサーバ(以下，業務システムサーバという)を社内LANに設置している。A社のネットワーク構成を，図1に示す。<br>
<img src="img/siken_img/security/pm01_1.gif"><br>
利用者は，業務システムを，社内LANに設置されたクライアントPCのWebブラウザから利用する。社外から社内LANへのリモートアクセスは禁止されている。業務システムの利用者認証は，A社認証サーバでの利用者IDとパスワード(以下，この二つを併せて利用者認証情報という)の検証によって行っており，シングルサインオンを実現している。<br>
　社内LANからインターネットを介した社外への通信は，クライアントPCからプロキシサーバを経由した，HTTP over TLS(以下，HTTPSという)による通信だけが，ファイアウォールによって許可されている。社外からインターネットを介した社内LANへの通信は，全てファイアウォールによって禁止されている。ファイアウォールの設定は，A社のセキュリティポリシに基づき変更しないものとする。<br>
<br>
〔クラウドサービスの利用者認証〕<br>
　このたびA社は，業務システムの一つである販売管理システムを，B社がインターネットを介して提供する販売管理サービス(以下，B社クラウドサービスという)に移行することにした。利用者認証に関しては，A社認証サーバとB社クラウドサービスを連携し，次の(1)～(3)を実現することにした。<br>
<br>
    <li>B社クラウドサービスをシングルサインオンの対象とする。</li><br>
    <li>A社の利用者認証は，B社クラウドサービスについても，A社認証サーバで行う。</li><br>
    <li>利用者が本人であることを確認するためにA社認証サーバで用いる[   a   ]は，B社クラウドサービスには送信しない。</li><br>
<br>
　(1)～(3)を実現するために，A社は，利用者認証を仲介するIDプロバイダ(以下，IdPという)を社内LANに設置することにした。IdPは，認証結果，認証有効期限及び利用者ID(以下，これら三つを併せて認証済情報という)にディジタル署名を付加してから，Webブラウザを介して，B社クラウドサービスに送信する。B社クラウドサービスは，付加されているディジタル署名を使って，受信した認証済情報に[   b   ]がないことを検証する。このために，IdPの[   c   ]をB社クラウドサービスに登録しておく。
　WebブラウザとB社クラウドサービスとの間，及びWebブラウザとIdPとの間の通信には，HTTPSを用いる。IdPとA社認証サーバとの間の通信にはLDAPを用いる。<br>
<br>
〔B社クラウドサービスが利用可能になるまでの処理の手順〕<br>
　A社の利用者が，利用者認証されていない状態で，B社クラウドサービスを利用しようとした場合に，利用可能になるまでの処理の手順を次の①～⑩に示す。<br>
<br>
    <li>利用者は，WebブラウザからB社クラウドサービスにアクセスの要求を送信する。</li><br>
    <li>B社クラウドサービスは，アクセスの要求をIdPに転送する指示(以下，転送指示という)を，Webブラウザに返信する。</li><br>
    <li>Webブラウザは，②の転送指示に従い，IdPにアクセスの要求を送信する。</li><br>
    <li>IdPは，利用者認証情報の入力画面をWebブラウザに返信する。</li><br>
    <li>利用者は，Webブラウザで利用者認証情報を入力する。Webブラウザは，入力された利用者認証情報をIdPに送信する。</li><br>
    <li>IdPは，利用者認証情報をA社認証サーバに送信する。</li><br>
    <li>A社認証サーバは，利用者認証情報を検証し，認証結果をIdPに返信する。</li><br>
    <li>IdPは，認証結果が成功の場合に，認証済情報を発行し，当該情報のB社クラウドサービスへの転送指示とともに，Webブラウザに返信する。</li><br>
    <li>Webブラウザは，⑧の転送指示に従い，認証済情報をB社クラウドサービスに送信する。</li><br>
    <li>B社クラウドサービスは，認証済情報に基づいて，B社クラウドサービスの利用を許可し，操作画面をWebブラウザに返信する。</li><br>
<br>
　B社クラウドサービスが利用可能になるまでの処理の流れを，図2に示す。図2中の①～⑩は，処理の手順の①～⑩と対応している。<br>
<img src="img/siken_img/security/pm01_2.gif"><br>
<h2>設問2</h2>
本文中の[      ]に入れる適切な答えを回答軍の中から選べ<br>
<div class="box1">a、b、c、に関する解答群<br>
  ア:PKI<br>
  イ:改ざん<br>
  ウ:公開鍵<br>
  エ:サービス妨害<br>
  オ:生体認証<br>
  カ:パスワード<br>
  キ:秘密鍵<br>
  ク:利用者ID<br>
  ケ:漏えい<br>
</div><br>
<div onclick="obj=document.getElementById('kaisetu_security_1').style; obj.display=(obj.display=='none')?'block':'none';"><a class="open_button" style="cursor: pointer;"><div class="box3">解説</div></a></div>
<div id="kaisetu_security_1" style="display: none;clear: both;">
答えはa=カ、b=イ、c=ウ、<br><br>
〔[   a   ]について〕<br>
[   a   ]は、利用者本人であることを確認するためにA社認証サーバで用いているものです。A社認証サーバでは利用者IDとパスワードの組合せによって利用者認証を行っているので、[   a   ]には利用者IDまたはパスワードのいずれかが入ります。
<br>
本文中に「IdPは，認証結果，認証有効期限及び利用者IDにディジタル署名を付加してから，…B社クラウドサービスに送信する。」とあることから、認証プロセス中に利用者IDをB社クラウドサービスに送信する仕様になっていることがわかります。したがって、[   a   ]にはもう一方のパスワードが入ります。<br>
<br>
∴[   a   ]＝カ：パスワード<br>
<br>
〔[   b   ]について〕<br>
aは、ディジタル署名を使って検証できるものが入ります。ディジタル署名の機能は「改ざんの検知」と「送信者の正当性の確認」なので、文脈と選択肢から改ざんが適切とわかります。<br>
<br>
∴[   b   ]＝イ：改ざん<br>
<br>
〔[   c   ]について〕<br>
ディジタル署名の手順は以下の通りです。<br>
<br>
    送信者は、平文をハッシュ関数で圧縮したメッセージダイジェストを送信者の秘密鍵で暗号化し、平文と一緒に送信します。<br>
    受信者は、受信したメッセージダイジェストを送信者の公開鍵で復号し、受信した平文をハッシュ関数で圧縮したものと比較します。<br>
    一つの平文からハッシュ関数によって生成されるメッセージダイジェストは常に同じになるため、送信者から送られてきたメッセージダイジェストと、受信側でハッシュ化したメッセージダイジェストが同じなら、通信内容が改ざんされていないことが証明されます。<br>
<br>
<img src="img/siken_img/security/pm01_3.gif"><br>
本問では、A社IdPが認証済情報にディジタル署名を付加してから、B社クラウドサービスに送信する手順になっています。認証済情報に付されたディジタル署名はA社IdPの秘密鍵で暗号化されているので、B社クラウドサービス側で行うディジタル署名の検証には「IdPの公開鍵」が必要になります。したがって、B社クラウドサービスに登録しておくのはIdPの公開鍵です。
<br>
∴c＝ウ：公開鍵<br>
</div><br><br>
<h2>設問2</h2><br>
次の記述中の　に入れる適切な答えを，解答群の中から選べ。<br>
<br>
　B社クラウドサービスでは，接続元のIPアドレスをA社のものに限定する機能は提供されていない。しかし，他の業務システムと同様に，B社クラウドサービスを，社内LANからの利用に限定できる。
　この理由は，dことが必要であるが，IdPを社内LANに設置するので，社外からB社クラウドサービスを利用しようとしても，図2中のeの送信で失敗し，利用者認証されないからである。<br>
<div class="box1">
  d に関する解答群<br>
<br>
    ア:B社クラウドサービスが，IdPと直接通信する<br>
    イ:B社クラウドサービスが，利用者認証情報を検証し，Webブラウザに返信する<br>
    ウ:IdPが，利用者に代わって，利用者認証情報をB社クラウドサービスに送信する<br>
    エ:Webブラウザが，IdPと通信する<br>
</div><br>
<div class="box1">
  d に関する解答群<br>
<br>
    ア:①<br>
    イ:③<br>
    ウ:⑤<br>
    エ:⑥<br>
    オ:⑩<br>

</div><br>
<div onclick="obj=document.getElementById('kaisetu_security_2').style; obj.display=(obj.display=='none')?'block':'none';"><a class="open_button" style="cursor: pointer;"><div class="box3">解説</div></a></div>
<div id="kaisetu_security_2" style="display: none;clear: both;">
  〔[   d   ]について〕<br>
<br>
    ア:図2のシーケンス図を見てもわかるように、B社クラウドサービスとIdPは直接通信を行うことはありません。<br>
    イ:利用者認証情報(利用者IDとパスワード)を検証するのはA社認証サーバです。認証結果はA社IdPに返されます。<br>
    ウ:IdPが生成した認証済情報は、Webブラウザへの転送指示を介してB社クラウドサービスに送信されます。<br>
    エ:正しい。処理手順③～⑤及び⑧で、WebブラウザとIdPは直接通信します。これを無くしてB社クラウドサービスとのシングルサインオンは実現できません。<br>
<br>
∴[   d   ]＝エ：Webブラウザが，IdPと通信する<br>
<br>
〔[   e   ]について〕<br>
A社では、社外から社内LANへのリモートアクセスが禁止されています。また、社外からインターネットを介した社内LANへの通信は、全てファイアウォールによって禁止されています。これにより、各業務システムと通信できるのは社内LANのみに限定されています。<br>
<br>
社外の端末からB社クラウドサービスを利用する場合を考えると、以下のようになります。<br>
<br>
    利用者は、WebブラウザからB社クラウドサービスにアクセスの要求を送信する。<br>
    →B社クラウドサービスでは、接続元のIPアドレスを制限していないので禁止されない。<br>
    B社クラウドサービスは、アクセス要求をIdPに転送する指示を、Webブラウザに返信する。<br>
    Webブラウザは、②の転送指示に従い、IdPにアクセスの要求を返信する。<br>
    →インターネットを介した社内LANへの通信となるので、ファイアウォールで遮断される。<br>
<br>
社外からB社クラウドサービスを利用しようとしても、社内に設置されているIdPと通信する③の段階で送信が失敗し、利用者認証を受けられません。B社クラウドサービスの利用者認証はA社認証サーバで行われるため、社内LANとの通信ができなければB社クラウドサービスの利用もできません。この理由により、B社クラウドサービスを(IdPと通信可能な)社内LANからの利用に限定できます。<br>
<br>
∴[   e   ]＝イ：③<br>
</div><br>


    <div class="top_box">
    <a href="#top"align="right">トップへ戻る</a></div>
    <br>
  </div><br>
   </div>

<div class="contents" id="page2">
   <div class="d1-2">
<h2 id="i1-2">データベース</h2>


     <div class="top_box">
     <a href="#top"align="right">トップへ戻る</a></div>
     <br>
   </div><br>
 </div>

<div class="contents" id="page3">
    <div class="d1-3">
    <h2 id="i1-3">3問目</h2>
ハードウェア<br>


      <div class="top_box">
      <a href="#top"align="right">トップへ戻る</a></div>
      <br>
    </div><br>
  </div>

<div class="contents" id="page4">
    <div class="d1-4">
    <h2 id="i1-4">データ構造とアルゴリズム</h2>
    問8　データ構造及びアルゴリズム<br>
    ハフマン符号化を用いた文字列圧縮に関する次の記述を読んで，設問1～3に答えよ。<br>
    <br>
    　"A"～"D"の4種類の文字から成る文字列をハフマン符号化によって圧縮する。ハフマン符号化では，出現回数の多い文字には短いビット列を，出現回数の少ない文字には長いビット列を割り当てる。ハフマン符号化による文字列の圧縮手順は，次の(1)～(4)のとおりである。<br>
    <br>
        文字列中の文字の出現回数を求め，出現回数表を作成する。例えば，文字列"AAAABBCDCDDACCAAAAA"(以下，文字列αという)中の文字の出現回数表は，表1のとおりになる。<br>
        <img src="img/siken_img/algo/pm08_1.gif"><br>
        <li>文字の出現回数表に基づいてハフマン木を作成する。<br>
ハフマン木の定義は，次のとおりである。<br>
<br>
    節と枝で構成する二分木である。<br>
    親である節は，子である節を常に二つもち，子の節の値の和を値としてもつ。<br>
    子をもたない節(以下，葉という)は文字に対応し，出現回数を値としてもつ。<br>
    親をもたない節(以下，根という)は，文字列の文字数を値としてもつ。<br>
<br>
文字列αに対応するハフマン木の例を，図1に示す。</li><br>
<img src="img/siken_img/algo/pm08_2.gif"><br>
ハフマン木は，次の手順で配列によって実現する。<br>
<br>
    <li>節の値を格納する1次元配列を用意する。</li><br>
    <li>文字の出現回数表に基づいて，各文字に対応する葉の値を，配列の先頭の要素から順に格納する。</li><br>
    <li>親が作成されていない節を二つ選択し，選択した順に左側の子，右側の子とする親の節を一つ作成する。この節の値を，配列中で値が格納されている最後の要素の次の要素に格納する。節の選択は節の値の小さい順に行い，同じ値をもつ節が二つ以上ある場合は，配列の先頭に近い要素に値が格納されている節を選択する。</li><br>
    <li>親が作成されていない節が一つになるまで③を繰り返す。</li><br>
<br>
<li>ハフマン木から文字のビット列(以下，ビット表現という)を次の手順で作成する。</li><br>
<br>
    <li>親と左側の子をつなぐ枝に0，右側の子をつなぐ枝に1の値をもつビットを割り当てる。<br>
    <li>文字ごとに根から対応する葉までたどったとき，枝のビット値を順に左から並べたものを各文字のビット表現とする。</li><br>
<br>
図2に示すとおり，根から矢印のようにたどると，文字列αの文字"B"のビット表現は010となる。<br>
<br>
<img src="img/siken_img/algo/pm08_3.gif">
<li>文字列の全ての文字を(3)で得られたビット表現に置き換えて，ビット列を作成する。</li><br>

<h2>設問1</h2>
次の記述中の　に入れる正しい答えを，解答群の中から選べ。

　文字列"ABBBBBBBCCCDD"を，ハフマン符号化を用いて表現する。各文字とビット表現を示した表はaである。ハフマン符号化によって圧縮すると，文字"A"～"D"をそれぞれ2ビットの固定長で表現したときの当該文字列の総ビット長に対する圧縮率はbとなる。ここで，圧縮率は次式で計算した値の小数第3位を四捨五入して求める。<br>
<img src="img/siken_img/algo/pm08_4.gif"><br>
<div class="box1">
  ア:<img src="img/siken_img/algo/pm08_5a.gif"><br>
  イ:<img src="img/siken_img/algo/pm08_5i.gif"><br>
  ウ:<img src="img/siken_img/algo/pm08_5u.gif"><br>
  エ:<img src="img/siken_img/algo/pm08_5e.gif"><br>
</div>
<div class="box1">
  ア:0.77<br>
  イ:0.85<br>
  ウ:0.88<br>
  エ:0.92<br>
</div>
<div onclick="obj=document.getElementById('kaisetu_algo_1').style; obj.display=(obj.display=='none')?'block':'none';"><a class="open_button" style="cursor: pointer;"><div class="box3">解説</div></a></div>
<div id="kaisetu_algo_1" style="display: none;clear: both;">
  〔[   a   ]について〕
  文字列"ABBBBBBBCCCDD"における各文字の出現回数は以下の通りです。<br>
  <img src="img/siken_img/algo/pm08_11.gif"><br>
  本文中に説明されているハフマン木の作成手順に従って、上記のデータからハフマン木を作成します。<br>
<br>
ハフマン木は、出現回数の少ない順に節を2つ選択し、選択した順に左の子、右の子とする親の節を作成する操作を繰り返すことで作成されます。まず、上記のデータのうち、出現回数の少ない"A"と"D"が選択されて以下のような木が生成されます。また、配列の最後に節の値を(1＋2＝)3とする親の節の要素が追加されます。<br>
<img src="img/siken_img/algo/pm08_12.gif"><br>
以下、親が作成されていない節が1つになるまで、この操作を繰り返します。次は、値がともに3である"C"と"ADの親"が選択され、以下のような木が生成されます。また、配列の最後に節の値を(3＋3＝)6とする親の節の要素が追加されます。<br>
<img src="img/siken_img/algo/pm08_13.gif"><br>
次は、"C・ADの親"と"B"が選択され、以下のような木が生成されます。また、配列の最後に節の値を(6＋7＝)13とする親の節の要素が追加されます。<br>
<img src="img/siken_img/algo/pm08_14.gif"><br>
この時点で、親が作成されていない節が1つになるのでハフマン木の完成となります。各節から出る左の枝に"0"を、右の枝に"1"を割り当てると次のようになります。<br>
<img src="img/siken_img/algo/pm08_15.gif"><br>
根から各文字までをたどると、A＝010、B＝1、C＝00、D＝011 というビット表現が得られます。したがって「ア」の組合せが適切です。,<br>
<br>
∴a＝[   ア   ]<br>
<br>
〔[   b   ]について〕<br>
2ビットの固定長で各文字を表現するとは、4つの文字のそれぞれに"00, 01, 10, 11"という異なる2ビット表現を割り当て、各文字を2ビットで表現するということです。文字列"ABBBBBBBCCCDD"は13文字ですので、2ビットの固定長で表現したときの総ビット長は、<br>
<br>
　2ビット×13文字＝26ビット<br>
<br>
ハフマン符号化後の総ビット長は、「各文字のビット長×出現回数」の総和になります。<br>
<br>
　3×1＋1×7＋2×3＋3×2＝22ビット<br>
<br>
圧縮率は、<br>
<br>
　22ビット÷26ビット＝0.8461…<br>
　(小数第3位を四捨五入して)0.85<br>
<br>
したがって「イ」が正解です。<br>
<br>
∴[   b   ]＝イ：0.85<br>
<br>

</div>
<br>
<h2>設問2</h2>
ハフマン木を作成するプログラム1の説明及びプログラム1を読んで，プログラム1中の　に入れる正しい答えを，解答群の中から選べ。<br>
<br>
〔プログラム1の説明〕<br>
<br>
    <li>四つの1次元配列 parent，left，right 及び freq の同じ要素番号に対応する要素の組み(以下，要素組という)によって，一つの節を表す。要素番号は0から始まる。四つの配列の大きさはいずれも十分に大きく，全ての要素は－1で初期化されている。</li><br>
    <li>図3に，図1に示したハフマン木を表現した場合の各配列の要素がもつ値を示す。配列 parent には親，配列 left には左側の子，配列 right には右側の子を表す要素組の要素番号がそれぞれ格納され，配列 freq には節の値が格納される。節が葉のとき，配列 left と配列 right の要素の値は，いずれも－1である。図3では，要素番号0～3の要素組が，順に文字"A"～"D"の葉に対応している。節が根のとき，配列 parent の要素の値は－1である。</li><br>
    <img src="img/siken_img/algo/pm08_6.gif"><br>
    <li>副プログラム Huffman は，次の①～⑤ を受け取り，ハフマン木を表現する配列を作成する。<br>
<br>
        <ul>葉である節の個数 size</ul>
        <ul>初期化された配列 parent</ul>
        <ul>初期化された配列 left</ul>
        <ul>初期化された配列 right</ul>
        <ul>初期化された後，文字の出現回数が要素番号0から順に格納された配列 freq</ul>

    <li>副プログラム SortNode は，親が作成されていない節を抽出し，節の値の昇順に整列し，節を表す要素組の要素番号を順に配列 node に格納し，その個数を変数 nsize に格納する。行番号19～24で親が作成されていない節を表す要素組の要素番号を抽出し，行番号25で節の値の昇順に整列する。</li>
    <li>副プログラム Sort (プログラムは省略)は，節を表す要素組の要素番号の配列 node を受け取り，要素番号に対応する要素組が表す節の値が昇順となるように整列する。節の値が同じときの順序は並べ替える直前の順序に従う。</li>
    <li>副プログラム Huffman，SortNode 及び Sort の引数の仕様を，表2～4に示す。</li>
    <img src="img/siken_img/algo/pm08_7.gif"><br>
    <img src="img/siken_img/algo/pm08_8.gif"><br>
    <div class="box1">
      c，d に関する解答群<br>
<br>
    ア:nsize≧0<br>
    イ:nsize≧1<br>
    ウ:nsize≧2<br>
    エ:parent[i]＜0<br>
    オ:parent[i]＞0<br>
    カ:size≦nsize<br>
    キ:size≧nsize<br>
    </div>
    <div onclick="obj=document.getElementById('kaisetu_algo_2').style; obj.display=(obj.display=='none')?'block':'none';"><a class="open_button" style="cursor: pointer;"><div class="box3">解説</div></a></div>
    <div id="kaisetu_algo_2" style="display: none;clear: both;">
      答えは、c=ウ、d=エ、<br>
      解説<br>
      プログラムの流れ上、[   d   ]→[   c   ]の順に解説します。<br>
<br>
〔[   d   ]について〕<br>
(4)の説明を読むと、副プログラム SortNode は、次の4つの処理を行うことがわかります。<br>
<br>
    親の作成されていない節を抽出する<br>
    節の値の昇順に整列する<br>
    節を表す要素組の要素番号を順に配列 node に格納する<br>
    配列 node の個数を nsize に格納する<br>
<br>
また、SortNode の引数の仕様を見ると、nsize と node[] は出力用の変数であることがわかります。<br>
<br>
nsize<br>
    配列 node 内の，整列対象とした節の個数<br>
node[]<br>
    節の値の昇順に格納した，親が作成されていない節を表す要素組の要素番号を格納した配列<br>
<br>
〔プログラム1〕の21行目では、node[] 及び nsize に値を格納する次の処理を行っています。<br>
<div class="box2">node[nsize] ← i<br>
nsize ← nsize + 1<br></div>
node[] に格納する値は、親が作成されていない要素組の要素番号だけなので、[   d   ]には親が作成されていない場合に真となる条件式が入ることになります。<br>
<br>
処理対象となっている要素組に親が存在するか否かは parent[] の値で判断できます。parent[] の各要素の値は、対応する要素組に親が作成されていなければ－1が、親が作成されていれば0以上が格納されているので、parent[i]の値が0未満（要するに－1）であれば親が作成されていない要素組であると判断できます。以上より、[   d   ]には「parent[i] < 0」が入るとわかります。<br>
<br>
∴[   d   ]＝エ：parent[i] < 0<br>
<br>
〔[   c   ]について〕<br>
[   c   ]には、ハフマン木の作成過程において処理を繰り返すときの継続条件を表す式が入ります。本文中から該当する部分を探すと、ハフマン木の作成手順中に「親が作成されていない節が一つになるまで③を繰り返す」とあります。これが継続条件になります。<br>
<br>
プログラムを見ると"繰返し処理に入る前"と"繰返し処理の最後"で SortNode が実行されています。この処理によって、nsize には親が作成されていない要素組の数が格納されています。親が作成されていない節が一つになるまで繰り返す、ということは nsize が1まで減ったら繰返しが終了するということです。繰返しを続行するのは nsize が1より大きい(=2以上の)ときですので、[   c   ]には「nsize ≧ 2」が入ります。<br>
<br>
∴[   c   ]＝ウ：nsize ≧ 2<br>
</div><br>





      <div class="top_box">
      <a href="#top"align="right">トップへ戻る</a></div>
      <br>
    </div><br>
  </div>

<!--<div class="contents" id="page4">
    <div class="d1-4">
<h2 id="i1-4">データ構造及びアルゴリズム</h2>
<div class="box1">
  <div class="box3"><big>基本情報技術者過去問題 平成28年秋期 午後問8</big></div><br><br>

  次のプログラムの説明及びプログラムを読んで、設問1~3に答えよ。<br>

　事務計算においては，数値を見やすく表示(印字)するために，例えば3桁ごとに区切りの","を挿入する<br>
などの編集処理がよく行われる。<br>
　関数 Edit は，指定された編集パターンに従って，数値を編集するプログラムである。<br>
表1に，関数 Edit を用いた編集例を示す。例1では，3桁ごとに区切りの","を挿入している。<br>
例2では，例1の編集に加え，上位の空いた桁を"＊"で埋めている。<br>
例3では，数値の右端から2桁目と3桁目の間に"."を挿入している。<br>
<img src="img/siken_img/pm08_1.gif" alt=""><br>
ここで，編集パターン中の文字"▯"及び"▮"は，数字と対応付けされた制御文字を表している。また，"␣"は空白文字を表している。<br>
<br>
〔プログラムの説明〕<br>
<br>
    関数 Edit は，次の形式で呼び出され，二つの引数をもつ。<br>
    　　関数：Edit(文字型: Pattern[]，文字型:Value[])<br><br>
    　Pattern[] には，編集パターンの文字列が格納されている。Value[] には，編集する数値を表す文字列が格納されている。各配列の添字は，0から始まる。文字列 Pattern[] のi番目の文字は Pattern[i－1] と表記する。文字列 Value[] についても同様である。<br>
    Pattern[] は，1文字以上から成る文字列であって，表示可能な図形文字及び制御文字("▯"及び"▮")から構成される。<br><br>
    Value[] は，数値を表す文字列であって，数字"0"～"9"の並びの後に，数値が正又は0なら"＋"を，負なら"－"を付加した形式である。数字の個数は，Pattern[] 中の文字"▯"及び"▮"の個数と一致するように，必要であれば前方に"0"を付加する。例えば，Pattern[] の内容が"＊▯▯,▯▮▯"のとき，Value[] には，数値が123なら"00123+"，0なら"00000+"，－123なら"00123-"を指定する。<br><br>
    関数 Edit は，Value[] で与えられた数値を Pattern[] に従って編集し，編集結果で Pattern[] を置き換える。<br>
    〔編集方法〕<br>
    　Pattern[] 中の各文字について，先頭から順に1文字ずつ，次の①～③のいずれか一つの操作を実行していく。<br>
        関数 Edit が呼び出されたときの Pattern[] 中の先頭の文字(以下，fill文字という)で置き換える。<br>
        Value[] 中の対応する桁の数字で置き換える。<br>
        置き換えないで，そのまま残す。<br><br>
    論理型変数 signif は，on 又は off の値を取る。この変数の実行開始時の値は off であり，Value[] 中に最上位から"0"が連続した後に"0"でない数字が見つかると on になる，などの使い方をする。<br><br>
    関数 Edit が呼び出されるとき，各引数には正しい値が設定されているものとする。<br>
<br>
<img src="img/siken_img/pm08_3.gif" alt=""><br>
</div>


      <div class="top_box">
      <a href="#top"align="right">トップへ戻る</a></div>
      <br>
    </div><br>
  </div>-->

<div class="contents" id="page5">
     <div class="d1-5">
 <h2 id="i1-5">表計算</h2>
 次の表計算のワークシート及びマクロの説明を読んで，設問1，2に答えよ。<br>
 <br>
 〔表計算の説明〕<br>
 　小売販売のZ店では，会員として登録した顧客に会員カードを発行して販売促進活動に利用している。このたび，会員への2018年10月1日から2019年3月31日までの期間(以下，対象期間という)の販売データを基に，販売促進キャンペーンを実施することにした。<br>
 <br>
 〔ワークシート:販売データ〕<br>
 　ワークシート"販売データ"には，対象期間における会員への販売データが，販売日の昇順で格納されている。ワークシート"販売データ"の例を，図1に示す。<br>
<br>
<img src="img/siken_img/pm13_1.gif" alt=""><br>
<li>列Aのレシート番号は，1回の販売ごとに発行される一意の番号である。1回の販売で複数の種類の商品を販売したときは商品コードごとに行を替えて連続して格納し，同じレシート番号を付す。</li><br>
<li>列Bの販売日は，商品を販売した日付である。日付は，1900年1月1日からの経過日数として記録され，表計算ソフトの機能によって，yyyy-mm-dd(年-月-日)の形式で表示される。</li><br>
<li>列Cの会員番号は，1001～9999の一意の数値である。</li><br>
<li>列Dの商品コードは販売した商品の商品コード，列Eの単価は販売単価，列Fの数量は販売数量，列Gは販売金額(単価×数量)である。<br>
<li>列Hの会員販売通番は，上位4桁を会員番号，下位3桁を会員ごとの販売の通番とする7桁の数値である。会員ごとの販売の通番は，行2から当該行までに格納された当該行の会員番号をもつ会員に対する販売回数であり，1,000未満である。ただし，同じレシート番号が続くときの二つ目以降の当該セルの値は0である。</li><br>
<li>同じレシート番号をもつ販売データの販売日及び会員番号は，全て同じである。</li><br>
<li>販売データは9,998件以下であり，販売データが入力されていない行の各セルには，空値が格納されている。</li><br>
<br><br>
<big>〔ワークシート:会員管理〕</big><br>
　ワークシート"会員管理"には，ワークシート"販売データ"のデータを基に，会員への販売状況や，販売促進キャンペーンのための情報を格納する。ワークシート"会員管理"の例を，図2に示す。<br>
<img src="img/siken_img/pm13_2.gif" alt=""><br>
<li>セル B1 の数値は，ワークシート"販売データ"に格納した販売データの行数である。セル E1 の数値は，会員数であり，ワークシート"会員管理"の行4以降に格納したデータの行数に等しい。</li><br>
<li>列Aの行4以降には，全ての会員の会員番号を昇順に格納する。</li><br>
<li>列Bの販売額合計は，ワークシート"販売データ"の中にある当該行の会員番号をもつ会員に対する販売金額の合計である。</li><br>
<li>列Cの販売回数は，ワークシート"販売データ"中にある，当該行の会員番号をもつ会員に対する販売回数である。</li><br>
<li>列Dの最終販売日は，当該行の会員番号をもつ会員に対して最後に販売した日付である。対象期間に販売の記録がないときは，空値である。</li><br>
<li>列Eの会員クラスは，当該行の会員番号をもつ会員を，下に示すクラス分類のルールに従って分類した結果である。</li><br>
<li>列Fのクーポンは，キャンペーンで当該行の会員番号をもつ会員に発行するクーポンの総額である。クーポンはZ店で1枚1,000円として使用できる券であり，販売額合計が50,000円以上100,000円未満で1枚，100,000円以上150,000円未満で2枚，… というように販売額合計の50,000円ごとに1枚を発行する。</li><br>
<br>
〔クラス分類のルール〕<br>
<li>対象期間における各会員の販売額合計と販売回数を，表1に示すランク分類基準に従って，それぞれランク1～3に分類する。</li><br>
<img src="img/siken_img/pm13_3.gif" alt=""><br>
<li>ワークシート"分類表"を参照して，会員をS，A，B，Cのクラスに分類する。表1のランク分類基準に基づいて作成したワークシート"分類表"を，図3に示す。</li><br>
<img src="img/siken_img/pm13_4.gif" alt=""><br>
<li>セル D2～F2 には販売額合計のランクを示す値が，セル D3～F3 には販売額合計をセル D2～F2 のランクに分類するときの販売額合計の下限が格納されている。</li><br>
<li>セル B4～B6 には販売回数のランクを示す値が，セル C4～C6 には販売回数をセル B4～B6 のランクに分類するときの販売回数の下限が格納されている。</li><br>
<li>セル D4～F6 には，当該セルの属する販売額合計と販売回数のランクから決まる会員クラスを示す"S'，"A"，"B"，"C"のいずれかが格納されている。</li><br>
<h2>設問1</h2><br>
  ワークシート"会員管理"に関する次の記述中の[      ]に入れる正しい答えを，解答群の中から選べ。<br>
  <li>セル B4 に販売額合計を求める式を入力し，セル B5～B9002 に複写する。</li><br>
  <li>セル C4 に販売回数を求める式を入力し，セル C5～C9002 に複写する。</li><br>
  <li>セル D4 に最終販売日を求める次の式を入力し，セル D5～D9002 に複写する。<br>
  　IF(論理和(A4＝null,C4＝0),null,[   a   ])</li><br>
  <li>セル E4 に会員クラスを求める次の式を入力し，セル E5～E9002 に複写する。<br>
  　IF(A4＝null,null,表引き(分類表!D$4:F$6,[   b   ]))</li><br>
  <li>セル F4 にクーポンの総額を求める次の式を入力し，セル F5～F9002 に複写する。</li><br>
  　IF(A4＝null,null,[   c   ]))<br>
  <div class="box1">
  a に関する解答群<br>
  ア:照合検索(A4,販売データ!C$2:C$9999,販売データ!A$2:A$9999)<br>
  イ:照合検索(A4,販売データ!C$2:C$9999,販売データ!B$2:B$9999)<br>
  ウ:照合検索(A4＊1000＋1,販売データ!H$2:H$9999,販売データ!A$2:A$9999)<br>
  エ:照合検索(A4＊1000＋1,販売データ!H$2:H$9999,販売データ!B$2:B$9999)<br>
  オ:照合検索(A4＊1000＋C4,販売データ!H$2:H$9999,販売データ!A$2:A$9999)<br>
  カ:照合検索(A4＊1000＋C4,販売データ!H$2:H$9999,販売データ!B$2:B$9999)<br>
</div><br>
<div class="box1">
b に関する解答群<br>
ア:照合一致(B4,分類表!C$4:C$6,1),照合一致(C4,分類表!D$3:F$3,1)<br>
イ:照合一致(B4,分類表!D$3:F$3,1),照合一致(C4,分類表!C$4:C$6,1)<br>
ウ:照合一致(C4,分類表!C$4:C$6,1),照合一致(B4,分類表!D$3:F$3,1)<br>
エ:照合一致(C4,分類表!D$3:F$3,1),照合一致(B4,分類表!C$4:C$6,1)<br>
</div><br>
<div class="box1">
c に関する解答群<br>
ア:切捨て(B4,－4)／50000＊1000<br>
イ:切捨て(B4＊1000,－8)／50000<br>
ウ:切捨て(B4／50000,0)＊1000<br>
エ:切捨て(B4／50000*1000,0)<br>
オ:切捨て(B4／50000*1000,－4)<br>
</div><br>

<div onclick="obj=document.getElementById('kaisetu1').style; obj.display=(obj.display=='none')?'block':'none';"><a class="open_button" style="cursor: pointer;"><div class="box3">解説</div></a></div>
<div id="kaisetu1" style="display: none;clear: both;">
  答えは、a=カ、b=ウ、c=ウ、<br><br>
  〔aについて〕<br>
処理aを囲んでいるIF関数の論理式と処理分岐は以下の通りです。<br>
論理式：A4(会員番号)が空白、あるいは、C4(販売回数)が0：<br>
　真の場合：何も表示しない。<br>
　偽の場合：処理aを行う。<br>
これは、処理対象から空白行及び会員ではあるが期間内の販売がない会員の行を除くものであるため、本題である「最終販売日」を求める式を選択すれば回答となります。<br>
<br>
まず「ア」と「イ」は、選択欄の照合検索の検索値として「A4(会員番号)」を指定しています。そして、照合検索の検索条件のセル範囲の引数として、販売データ表のC列を指定しています。したがって、照合検索ではC列の"会員番号"が第1引数で指定された会員番号である行を上端から順に検索することとなります。購入回数が1回のみの会員ならばこれでも最終販売日が取得できますが、同じ会員が複数回購入している場合、そのうち最も上の行、すなわち最初の販売日のデータが取得されてしまうため誤りです。<br>
<br>
残る4つの式は、販売データ表のH列、すなわち"会員販売通番"を対象に検索しています。この"会員販売通番"は上4桁が会員番号、下3桁が当該行の会員番号をもつ会員に対する販売回数(1,000未満)となっています。<br>
<br>
最終販売日を求めたいのですから、販売データ表内でその会員に最後に販売したデータにアクセスする必要があります。会員管理表の販売回数の値は、期間内に当該会員に販売した回数ですから、最後に販売したデータの"会員販売通番"は「会員番号＋販売回数」になっているはずです。「ウ」と「エ」では、C4(販売回数)でなく固定値の1を加算しているので、常に当該顧客の最初の販売日を取得することになってしまいます。よって、「ウ」「エ」は誤りです。<br>
<br>
残った2つのうち、「オ」は、照合検索の抽出するセルの範囲に販売データ表のA列"レシート番号"を指定しているため誤りです。これで取得できるのは、その会員に最後に販売したデータのレシート番号になってしまいます。一方「カ」は、抽出するセルの範囲に販売データ表のB列"販売日"指定しているため「最終販売日」が取得できます。よって、aに入る式としては「カ」が適切です。<br>
<br>
∴a＝カ<br>
<br>
〔bについて〕<br>
処理bを囲んでいるIF関数は、処理aと同様です。<br>
ここでは、本題である「会員クラス」を求める式を選択すれば回答となります。<br>
<br>
bは、表引き関数の第2・3引数に当たるため、第2引数には行番号を返す照合一致、第3引数には列番号を返す"照合一致"が使われています。"照合一致"の第2・第3引数は、行番号、列番号の順である必要があります。<br>
<br>
分類表を見ると、行番号で販売回数のランクを、列番号で販売額合計をランクを判定し、重なり合ったところが会員クラスの値になっています。「ア」と「イ」は、第2引数にB4(販売額合計)、第3引数にC4(販売回数)というように行・列を逆に指定しているため誤りです。<br>
<br>
残った「ウ」と「エ」のうち、「エ」は照合一致の範囲を逆に指定しているため誤りです。よって、bに入る式としては「ウ」が適切です。<br>
<br>
∴b＝ウ<br>
<br>
〔cについて〕<br>
処理cを囲んでいるIF関数は、処理aと同様です。<br>
ここでは、本題である「クーポンの総額」を求める式を選択すれば答えとなります。クーポンは「販売額合計」の50,000円ごとに1枚発行されます。<br>
<br>
仮の値を用いて、販売額合計からクーポンの総額が正しく求められるかを検証していきます。仮に販売合計額を170,000円とすると、式の答えとなるべきクーポンの総額は3,000円となります。<br>
<br>
    　切捨て(170000, -4)／50000＊1000<br>
    ＝170000／50000＊1000<br>
    ＝3.4＊1000＝3400 …×<br>
    　切捨て(170000＊1000, -8)／50000<br>
    ＝100000000÷50000＝2000 …×<br>
    　切捨て(170000／50000, 0)＊1000<br>
    ＝切捨て(3.4, 0)＊1000<br>
    ＝3＊1000＝3000 …〇<br>
    　切捨て(170000／50000＊1000, 0)<br>
    ＝切捨て(3400, 0)＝3400 …×<br>
    　切捨て(170000／50000＊1000, -4)<br>
    ＝切捨て(3400, -4)＝0 …×<br>
<br>
唯一、「ウ」の式だけが正しいクーポンの総額を算出可能です。<br>
<br>
∴c＝ウ<br>
</div>
<br>
<h2>設問2</h2>
新商品の見本の配布などの販売促進キャンペーンに活用するために，ワークシート"商品別管理"を作成し，マクロ manageMembers を格納した。マクロ manageMembers 中の　に入れる正しい答えを，解答群の中から選べ。<br>
<br>
〔ワークシート:商品別管理〕<br>
　セル B1 に商品の商品コードを入力して，マクロ manageMembers を実行すると，ワークシート"販売データ"及びワークシート"会員管理"に格納されているデータを基に，列Aの行3以降に当該商品を購入した会員の会員番号を，列Bの行3以降に会員番号ごとの当該商品の販売金額の合計(以下，商品販売額という)を，列Cの行3以降に会員番号ごとに最後に当該商品を販売した日付(以下，商品最終販売日という)を，それぞれ表示する。各行は同一会員に関する項目で構成し，商品販売額の降順に，商品販売額が等しいときは商品最終販売日の昇順に整列して表示する。ここで，マクロの実行開始時には，セル A3～C9001 に空値が格納されている。ワークシート"商品別管理"の例を，図4に示す。<br>
<img src="img/siken_img/pm13_5.gif"><br>
〔マクロ:manageMembersの説明〕
　このマクロは，9,001行3列の要素をもつ2次元配列 sumTab を用意し，1以上会員数以下の全ての整数 i に対して，sumTab[i，0]に会員番号を格納し，その会員番号に対応する商品販売額をsumTab[i，1]に，商品最終販売日をsumTab[i，2]に格納する。<br>
<br>
    <li>1以上会員数＋1以下の全ての整数 i に対して，sumTab[i，1]に初期値として0を格納する。</li><br>
    <li>ワークシート"販売データ"の行2以降のデータを上から順に参照し，商品コードがセル B1 で指定した値と等しいとき，当該データの会員番号に対応した2次元配列 sumTab の商品販売額の要素に販売金額を加算するとともに，商品最終販売日の要素に日付を格納する処理を繰り返す。</li><br>
    <li>2次元配列 sumTab の会員番号を格納した行を，商品販売額の降順に，商品販売額が等しいときは商品最終販売日の昇順に整列する。<li><br>
    <li>ワークシート"商品別管理"の行3以降のセルに，会員番号，商品販売額，商品最終販売日を，(3)の処理で整列された順に格納する。商品販売額が0の要素が現れたら，処理を終了する。</li><br>
    <img srs="img/siken_img/pm13_6.gif"><br>
    <div class="box1">
    d に関する解答群<br>
    ア:sumTab[1,index] ← sumTab[1,index]＋相対(販売データ!A1,i,6)<br>
    イ:sumTab[1,index] ← sumTab[i,index]＋相対(販売データ!A1,index,6)<br>
    ウ:sumTab[i,1] ← sumTab[i,1]＋相対(販売データ!A1,i,6)<br>
    エ:sumTab[i,1] ← sumTab[i,1]＋相対(販売データ!A1,index,6)<br>
    オ:sumTab[index,1] ← sumTab[index,1]＋相対(販売データ!A1,i,6)<br>
    カ:sumTab[index,1] ← sumTab[index,1]＋相対(販売データ!A1,index,6)<br></div>
<div class="box1">
    e に関する解答群<br>
    論理積(sumTab[j,1]＜sumTab[j＋1,1],論理和(sumTab[j,1]＝<br>
    sumTab[j＋1,1],sumTab[j,2]＞sumTab[j＋1,2]))<br>
    論理積(sumTab[j,1]＞sumTab[j＋1,1],<br>
    sumTab[j,2]＞sumTab[j＋1,2])<br>
    論理積(sumTab[j,1]＞sumTab[j＋1,1],論理和(sumTab[j,1]＝<br>
    sumTab[j＋1,1],sumTab[j,2]＜sumTab[j＋1,2]))<br>
    論理和(sumTab[j,1]＜sumTab[j＋1,1],<br>
    sumTab[j,2]＞sumTab[j＋1,2])<br>
    論理和(sumTab[j,1]＜sumTab[j＋1,1],論理積(sumTab[j,1]＝<br>
    sumTab[j＋1,1],sumTab[j,2]＞sumTab[j＋1,2]))<br>
    論理和(sumTab[j,1]＞sumTab[j＋1,1],論理積(sumTab[j,1]＝<br>
    sumTab[j＋1,1],sumTab[j,2]＜sumTab[j＋1,2]))<br></div>
    <div class="box1">
    f に関する解答群<br>
    相対(A2，i，j) ← sumTab[i，1]<br>
    相対(A2，i，j) ← sumTab[i，j]<br>
    相対(A2，i，j＋1) ← sumTab[i，j]<br>
    相対(A2，j，i) ← sumTab[j，1]<br>
    相対(A2，j，i) ← sumTab[j，i]<br>
    相対(A2，j＋1，i) ← sumTab[j, 1]<br></div>
    <div onclick="obj=document.getElementById('kaisetu2').style; obj.display=(obj.display=='none')?'block':'none';"><a class="open_button" style="cursor: pointer;"><div class="box3">解説</div></a></div>
    <div id="kaisetu2" style="display: none;clear: both;">
      答えは、d=オ、e=オ\、f=イ、、<br><br>
マクロ manageMembers は説明の(1)から(4)に対応した4つ部分で構成されています。
<img src="img/siken_img/pm13_7.gif"><br>
〔dについて〕<br>
ここでは、(2)内の記述である「当該データの会員番号に対応した2次元配列 sumTab の商品販売額の要素に販売金額を加算する」を実行します。変数宣言部を見ると sumTab は [9001, 3] と定義されています。つまり、添え字の1つ目が行番号、2つ目が列番号を示しています。また、sumTabは、会員管理表の値を先頭から順にコピーしているので、sumTab[i, 0]の会員番号は昇順に整列されていることになります。<br>
そして、変数 index には、セルB1(=集計対象の部品番号)と一致した行の行番号が格納されています。<br>
<br>
アとイは、両者とも sumTab の行番号として1を指定しています。これだと常に2行目に固定設定することになるため誤りです。<br>
ウとエは、両者ともカウンタ変数である i 番目に格納するため誤りです。iは販売データ表の現在参照している行位置を保持しています。商品販売額を加算するのは、sumTab内の当該会員番号の行でなければなりません。<br>
カは、相対位置に変数 index を指定するため誤りです。<br>
オは、index行の「商品販売額」に「販売データ」シートの販売額を加算した結果を設定するのが正しいので「オ」が正解です。<br>
<br>
∴d＝オ<br>
<br>
〔eについて〕<br>
ここでは、(3)内の記述である「商品販売額の降順に、商品販売額が等しいときは商品最終販売日の昇順に整列する」条件式を実行します。eには行の入れ替えを実行するか否かを判定するための条件式が入ります。<br>
<br>
入れ替えを実行すべき時は、<br>
<br>
    現在参照している行の商品販売額が、次の行の商品販売額よりも少ない<br>
    現在参照している行の商品販売額が、次の行の商品販売額が同じ、かつ、現在参照している行の最終販売日(sumTab[j, 2])が、次の行の最終販売日(sumTab[j+1, 2])よりも大きい<br>
<br>
という2つの条件のいずれかを満たす場合です。これをマクロの条件式に直すと<br>
<br>
    sumTab[j, 1] ＜ sumTab[j+1, 1])<br>
    (sumTab[j, 1] = sumTab[j+1, 1]) かつ (sumTab[j, 2] ＞ sumTab[j+1, 2])<br>
<br>
表計算では、andを論理積関数、orを論理和関数で表すので、2つの式を論理和で評価し、"かつ"の部分を論理積で評価すると、
<div class="box2">論理和(
sumTab[j,1]＜sumTab[j＋1,1],
論理積(sumTab[j,1]＝sumTab[j＋1,1],
　　　 sumTab[j,2]＞sumTab[j＋1,2])
)</div>
が適切な式です（見やすくするために数行に分けています）。<br>
<br>
アとイとウは、最初が論理積での指定のため誤りです。<br>
エは、「現在参照している行の商品販売額が、次の行の商品販売額が同じ」という条件が不足しているため誤りです。<br>
カは、不等号に向きが逆です。これだと「商品販売額が次の行より大きい場合」「最終販売日が次の行より小さい場合」となってしまい、商品販売額の昇順、最終販売日の降順に整列されてしまうため誤りです。<br>
オは、正しく条件を指定しているため正解です。<br>
<br>
∴e＝オ<br>
<br>
〔fについて〕<br>
ここでは(1)～(3)で該当行を抽出した後、整列済みの sumTab を変数iとjを使ってセルA2以降に順に出力すれば正解です。前述したように sumtab では[行, 列]でデータにアクセスします。また、相対も(基準セル, 行位置, 列位置)でセルを指定するので、単純に相対(A2, i, j)の位置に sumTab[i, j] の値を格納すれば良いことになります。<br>
<br>
アとエは、sumTab[i, 1]としており、商品別管理のどの列も商品販売額のデータになってしまいます。よって誤りです。<br>
ウは、出力先の相対列位置を j+1 としているため、B列に会員番号が、C列に商品販売額が、D列に最終販売日が表示されることになります。よって誤りです。<br>
オとカは、それぞれ出力先の相対位置としてiとjを逆に指定しているため誤りです。また、sumTabの指定もそれぞれ誤りです。<br>
イは、整列した sumTab のデータをiとjを使って順に出力するため正解です。<br>
<br>
∴f＝イ<br>
<br>
</div><br>

       <div class="top_box">
       <a href="#top"align="right">トップへ戻る</a></div>
       <br>
     </div><br>
   </div>
   <script>
   'use strict'
   document.getElementById("page1").style.display = "block";
   let disp = function(value){
   	let contents = document.getElementsByClassName("contents");
   	for(let content of contents){
   			content.style.display = "none";
   	}
   	let dispitem = document.getElementById(value);
   	dispitem.style.display = "block";
   }
   </script>
</div><!--中央揃えdiv-->
<script type="text/javascript">footer()</script>
</body>
</html>
